#ifndef VOutputBuffer_Interface
#define VOutputBuffer_Interface

/************************
 *****  Components  *****
 ************************/

#include "VBenderenceable.h"
#include "VTaskDomainedStore.h"

/**************************
 *****  Declarations  *****
 **************************/

#include "IOMDriver.h"

#include "m.h"

#include "venvir.h"
#include "RTptoken.h"

class VTask;


/*************************
 *****  Definitions  *****
 *************************/

/**************************
 *----  VOutputBuffer  ----*
 **************************/
/*---------------------------------------------------------------------------
 * VOutputBuffer::Cell's contain atomic units of output.  They are allocated
 * internally from large, simply managed buffers and are threaded together to
 * form printable output images.
 *
 *  Field Descriptions:
 *	m_pSuccessor		- the address of the next cell in the ring.
 *				  Typically, the next cell contains the next
 *				  piece of output generated by a message.
 *	m_iContent		- a null terminated string of arbitrary size
 *				  containing the output held in this cell.
 *				  Although declared as an array of length 1,
 *				  the actual amount of space allocated is
 *				  determined at run time.
 *
 * VOutputBuffer::Cell's are used to buffer task output.  Because tasks process
 * a number of instances simultaneously in the order best suited to the instances
 * and not the 'natural' order perceived by the user, output must be buffered for
 * display in the proper order.  The following picture may be worth a thousand
 * words:
 *
 * Vision Code:
 *		"The answer is: " print;
 *		17 print;
 *
 * Output Buffer State:
 *				Most
 *	Output	  Message	Recent		Oldest
 *	Buffer	  Rings		Output		Output
 *	------	  -------	-------		-------
 *	 _  Rings   _
 *	|*|------->| |
 *	|-|	   ~ ~
 *	|*|-----+  ~ ~
 *	+-+	|  |-|		------		------------------
 *		+->|*|-------->|*|17\0|<-------|*|The answer is:\0|<----+
 *	   Cursor  |-|		------		------------------	|
 *		   ~ ~		|					|
 *				+---------------------------------------+
 *
 *---------------------------------------------------------------------------
 */


class VOutputBuffer : public VTaskDomainedStore {
    DECLARE_CONCRETE_RTT (VOutputBuffer, VTaskDomainedStore);

/**************************************
 *----  VOutputBuffer::AllocatoR  ----*
 **************************************/
public:
    class AllocatoR : public VBenderenceable {
	DECLARE_CONCRETE_RTT (AllocatoR, VBenderenceable);

    //  Friends
	friend class VOutputBuffer;

    /*************************************************
     *----  VOutputBuffer::AllocatoR::CellBlock  ----*
     *************************************************/
    public:
	class CellBlock : public VTransient {
	    friend class VOutputBuffer;
	    friend class AllocatoR;

	/*******************************************************
	 *----  VOutputBuffer::AllocatoR::CellBlock::Cell  ----*
	 *******************************************************/
	public:
	    class Cell {
		friend class CellBlock;
		friend class VOutputBuffer;

	    //  Access
	    public:
		/*********************************************************************************
		 *  New 'Cell's need to provide enough space for their fixed and variable
		 *  content and sufficient padding to ensure that any cell allocated immediately
		 *  after this cell is naturally aligned.  The formula implemented by this
		 *  routine makes the necessary adjustments as follows:
		 *
		 *    + sRequest                ... space for the cell's variable content
		 *    + sizeof(Cell)            ... space for the cell's fixed content
		 *    - (sizeof(Cell) - offsetof(Cell,m_iContent))
		 *                              ... the amount of space already provided in
		 *                                  the cell for variable content
		 *    + sizeof(Cell) - 1        ... the maximum amount of space required to
		 *                                  pad the total allocation to a natural
		 *                                  alignment boundary.
		 *
		 *  Rewriting these requirements without comments or parentheses yields:
		 *
		 *    sRequest + sizeof(Cell) + offsetof(Cell,m_iContent) - sizeof(Cell) + sizeof(Cell) - 1
		 *
		 *  or:
		 *
		 *   sRequest + sizeof(Cell) + offsetof(Cell,m_iContent) - 1
		 *
		 *  In addition to this formula, there is also a 'legacy' formula (adjusted for
		 *  pointer size) that overestimates the size of the cell.  The overestimate is
		 *  based on the (incorrect) assumption that only 1 byte of variable content
		 *  storage is preallocated in the cell.  Using that assumption, the required
		 *  size is:
		 *
		 *    sRequest + sizeof(Cell) - 1 + sizeof(Cell) - 1
		 *
		 *  or:
		 *
		 *    sRequest + 2 * sizeof(Cell) - 2
		 *
		 *********************************************************************************/
		static size_t sizeFor (size_t sRequest) {
#ifdef __GNUG__
		 // EPLSDI (Execute Pedantic Language Standard Developer Immediate)
		    return rounded (sRequest + sizeof(Cell) + sizeof(Cell*)/* == offsetof(Cell,m_iContent)*/ - 1);
#else
		    return rounded (sRequest + sizeof(Cell) + offsetof (Cell,m_iContent) - 1);
#endif
		}
		static size_t legacySizeFor (size_t sRequest) {
		    return rounded (sRequest + 2 * sizeof(Cell) - 2);
		}
		    
		Cell* successor () const {
		    return m_pSuccessor;
		}
		char const* content () const {
		    return m_iContent;
		}
		char* content () {
		    return m_iContent;
		}

	    //  State
	    protected:
		Cell*	m_pSuccessor;
		char	m_iContent[1];
	    };

	/*----  VOutputBuffer::AllocatoR::CellBlock::Cell  ----*/
	//  Allocation
	protected:
	    static size_t g_iTotalAllocation;
	public:
	    void* operator new (size_t sStructure, size_t sCellBlock) {
		g_iTotalAllocation += sCellBlock;
		return VTransient::allocate (sStructure + sCellBlock);
	    }
	    // HP C-- seems to want this, so humor it, ...
	    void* operator new (size_t sStructure) {
		return VTransient::allocate (sStructure);
	    }

	    void operator delete (void *pStructure, size_t sCellBlock) {
		deallocate (pStructure);

	    }
	    void operator delete (void *pStructure) {
		deallocate (pStructure);
	    }

	//  Construction
	public:
	    CellBlock (CellBlock* pPredecessor, size_t sCellBlock);

	//  Destruction
	public:
	    ~CellBlock () {
	    }

	//  Access
	public:
	    CellBlock* predecessor () const {
		return m_pPredecessor;
	    }
	    CellBlock* successor () const {
		return m_pSuccessor;
	    }

	    size_t cellBlockSize () const {
		return this ? m_sCellBlock : 0;
	    }
	    size_t freeAreaSize () const {
		return this ? m_sFreeArea : 0;
	    }

	//  Allocation
	public:
	    bool canAllocate (size_t sRequired) const {
		return sRequired <= m_sFreeArea;
	    }
	    bool cantAllocate (size_t sRequired) const {
		return sRequired > m_sFreeArea;
	    }

	    CellBlock *allocate (Cell** ppRing, size_t sRequired) {
		//  Allocate the cell, ...
		Cell *const pCell = reinterpret_cast<Cell*>(m_pFreeArea);
		m_sFreeArea -= sRequired;
		m_pFreeArea += sRequired;

	    //  ... and link the new cell into its ring:
		Cell* pRingHead = *ppRing;
		if (IsNil (pRingHead))
		    pCell->m_pSuccessor = pCell;
		else {
		    pCell->m_pSuccessor = pRingHead->m_pSuccessor;
		    pRingHead->m_pSuccessor = pCell;
		}
		*ppRing = pCell;

		return this;
	    }

	//  Reclamation
	private:
	    void reclaim (size_t sExcess) {
		m_sFreeArea += sExcess;
		m_pFreeArea -= sExcess;
	    }
	public:
	    void reclaim (size_t sRequested, size_t sRequired) {
		reclaim (rounded (sRequested - sRequired));
	    }

	//  Rounding
	public:
	    static size_t rounded (size_t sRequest) {
		return sRequest / sizeof (Cell) * sizeof (Cell);
	    }

	//  State
	protected:
	    CellBlock*		m_pPredecessor;
	    CellBlock*		m_pSuccessor;
	    size_t const	m_sCellBlock;
	    size_t		m_sFreeArea;
	    char*		m_pFreeArea;
	};
	typedef CellBlock::Cell Cell;


    /*----  VOutputBuffer::AllocatoR  ----*/
    //  Counts
    protected:
	static unsigned int g_iLocalExtentExpansionCount;
	static unsigned int g_iGlobalExtentExpansionCount;

    //  Parameters
    protected:
	static size_t g_sInitialCellBlock;
	static size_t g_sLargestCellBlock;

    //  Construction
    public:
	AllocatoR ();

    //  Destruction
    protected:
	~AllocatoR ();

    //  Allocation
    public:
	CellBlock* allocate (Cell** ppRing, size_t sRequired);

    //  State
    protected:
	CellBlock*	m_pActiveBlock;
	size_t		m_sAllBlocks;
	size_t		m_sNextBlock;
    };
    friend class AllocatoR;

    typedef AllocatoR::Cell Cell;


/*----  VOutputBuffer  ----*/
//  Counts
public:
    static unsigned int cellAllocatorLocalExtentExpansionCount () {
	return AllocatoR::g_iLocalExtentExpansionCount;
    }
    static unsigned int cellAllocatorGlobalExtentExpansionCount () {
	return AllocatoR::g_iGlobalExtentExpansionCount;
    }

    static unsigned int cellAllocatorCurrentAllocationAmount () {
	return AllocatoR::CellBlock::g_iTotalAllocation;
    }

//  Parameters
public:
    static size_t cellAllocatorInitialExtentSize () {
	return AllocatoR::g_sInitialCellBlock;
    }

    static size_t cellAllocatorMaximumExtentSize () {
	return AllocatoR::g_sLargestCellBlock;
    }

public:
    static void setCellAllocatorInitialExtentSizeTo (size_t sCellBlock) {
	AllocatoR::g_sInitialCellBlock = sCellBlock;
    }

    static void setCellAllocatorMaximumExtentSizeTo (size_t sCellBlock) {
	AllocatoR::g_sLargestCellBlock = sCellBlock;
    }

//  Construction
public:
    //  Top Task
    VOutputBuffer (VTaskDomain* pDomain, IOMDriver* pChannel);

    //  Subtask/Diverting
    VOutputBuffer (VTaskDomain* pDomain, VOutputBuffer* pParent, bool fDiverting = false);

//  Destruction
protected:
    ~VOutputBuffer ();

//  Access/Query
public:
    IOMDriver* channel () const {
	return m_pChannel;
    }

    bool hasOutput () const {
	return IsntNil (m_pRingHeads);
    }

    bool isDivertingOutput () const {
	return m_fDiverting;
    }

    bool isntDivertingOutput () const {
	return !m_fDiverting;
    }

    VOutputBuffer* parent () const {
	return m_pParent;
    }

//  Ring Management
protected:
    void discardRings () {
	deallocate (m_pRingHeads);
	m_pRingHeads = 0;
    }
    Cell** newRings ();

public:
    Cell** rings () {
	return m_pRingHeads ? m_pRingHeads : newRings ();
    }

//  Output Generation
protected:
    void raiseSizeException (size_t size, size_t length) const;

public:
    void vprintf (
	Cell** ppRing, size_t size, char const* format, va_list	ap
    );
    void vprintf (
	Cell**		ppRing,
	size_t		size,
	int		fieldWidth,
	int		overflowChar,
	char const*	format,
	va_list		ap
    );
    void printWithCommas (
	Cell**		ppRing,
	size_t		size,
	int		overflowChar,
	int		fieldSpecification,
	int		precision,
	double		number
    );
    void putString (Cell** ppRing, char const* string);

//  Output Access
public:
    unsigned int characterCount (char iDelimiter) const;

    void copyOutputTo (IOMDriver* pOutputChannel) const;

    void copyOutputTo (char* pOutputReturnBuffer, char iDelimiter) const;

    void copyOutputTo (FILE* pStream, char const *pOmitString) const;

    void moveOutputTo (
	VOutputBuffer* pTarget, rtLINK_CType* pCallerSubset, M_CPD* pCallerReordering
    );

    void moveOutputTo () {
	discardRings ();
    }

    void moveOutputTo (IOMDriver* pOutputChannel) {
	copyOutputTo (pOutputChannel);
	discardRings ();
    }

    void moveOutputTo (char* pOutputReturnBuffer, char iDelimiter) {
	copyOutputTo (pOutputReturnBuffer, iDelimiter);
	discardRings ();
    }

    void moveOutputTo (FILE* pStream, char const *pOmitString) {
	copyOutputTo (pStream, pOmitString);
	discardRings ();
    }

    void moveOutputToChannel () {
	moveOutputTo (m_pChannel);
    }

//  State
protected:
    Reference			const	m_pParent;
    IOMDriver::Pointer		const	m_pChannel;
    AllocatoR::Reference	const	m_pAllocator;
    bool			const	m_fDiverting;
    Cell**				m_pRingHeads;
};


#endif
